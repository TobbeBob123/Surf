(()=>{var re=Object.defineProperty;var i=(g,p)=>re(g,"name",{value:p,configurable:!0});(()=>{"use strict";var g={};function p(n,e){return`${n}:${e}`}i(p,"getPresenceKey");function b(n){const[e,t]=n.p.split(".");return{userId:n.u,presenceKey:p(n.u,e),connectionCount:Number(t),metadata:n.m||[]}}i(b,"decompressItem");const E="presence-";function m(n){return n.startsWith(E)}i(m,"isPresenceChannel");class w{constructor(){this.presenceItems=new Map}shouldUsePresenceItem(e){const t=this.presenceItems.get(e.presenceKey);return!t||t.connectionCount<=e.connectionCount}addPresenceItem(e){!this.shouldUsePresenceItem(e)||this.presenceItems.set(e.presenceKey,e)}removePresenceItem(e){!this.shouldUsePresenceItem(e)||this.presenceItems.delete(e.presenceKey)}replacePresenceItems(e){this.presenceItems.clear();for(const t of e)this.addPresenceItem(t)}getPresenceItems(){return Array.from(this.presenceItems.values())}}i(w,"PresenceChannel");class k{constructor(){this.presenceChannels=new Map}getPresenceChannel(e){const t=this.presenceChannels.get(e)||new w;return this.presenceChannels.set(e,t),t}handleMessage(e,t){const s=this.getPresenceChannel(e);switch(t.e){case"pf":s.replacePresenceItems(t.d.map(b));break;case"pa":s.addPresenceItem(b(t.d));break;case"pr":s.removePresenceItem(b(t.d));break}return this.getChannelItems(e)}getChannelItems(e){return this.getPresenceChannel(e).getPresenceItems()}clearChannel(e){this.presenceChannels.delete(e)}}i(k,"AlivePresence");const d="_i";function _(n){return Object.assign(Object.assign({},n),{isLocal:!0})}i(_,"markMetadataAsLocal");class M{constructor(){this.subscriberMetadata=new Map}setMetadata(e,t){this.subscriberMetadata.set(e,t)}removeSubscribers(e){let t=!1;for(const s of e)t=this.subscriberMetadata.delete(s)||t;return t}getMetadata(e){if(!e){const o=[];let c;for(const a of this.subscriberMetadata.values())for(const h of a)if(d in h){const l=Boolean(h[d]);c=c===void 0?l:l&&c}else o.push(h);return c!==void 0&&o.push({[d]:c?1:0}),o}const t=[],{subscriber:s,markAllAsLocal:r}=e;for(const[o,c]of this.subscriberMetadata){const h=r||o===s?c.map(_):c;t.push(...h)}return t}hasSubscribers(){return this.subscriberMetadata.size>0}}i(M,"PresenceMetadataForChannel");class P{constructor(){this.metadataByChannel=new Map}setMetadata({subscriber:e,channelName:t,metadata:s}){let r=this.metadataByChannel.get(t);r||(r=new M,this.metadataByChannel.set(t,r)),r.setMetadata(e,s)}removeSubscribers(e){const t=new Set;for(const[s,r]of this.metadataByChannel)r.removeSubscribers(e)&&t.add(s),r.hasSubscribers()||this.metadataByChannel.delete(s);return t}getChannelMetadata(e,t){const s=this.metadataByChannel.get(e);return(s==null?void 0:s.getMetadata(t))||[]}}i(P,"PresenceMetadataSet");async function T(n,e){let t;const s=new Promise((r,o)=>{t=self.setTimeout(()=>o(new Error("timeout")),n)});if(!e)return s;try{await Promise.race([s,y(e)])}catch(r){throw self.clearTimeout(t),r}}i(T,"timeout");async function L(n,e){let t;const s=new Promise(r=>{t=self.setTimeout(r,n)});if(!e)return s;try{await Promise.race([s,y(e)])}catch(r){throw self.clearTimeout(t),r}}i(L,"wait");async function W(n,e,t=1/0,s){const r=s?y(s):null;for(let o=0;o<e;o++)try{return await(r?Promise.race([n(),r]):n())}catch(c){if(c.name==="AbortError"||o===e-1)throw c;const a=Math.pow(2,o)*1e3,h=B(a*.1);await L(Math.min(t,a+h),s)}throw new Error("retry failed")}i(W,"retry");function y(n){return new Promise((e,t)=>{const s=new Error("aborted");s.name="AbortError",n.aborted?t(s):n.addEventListener("abort",()=>t(s))})}i(y,"whenAborted");function B(n){return Math.floor(Math.random()*Math.floor(n))}i(B,"rand");async function F(n,e,t){const s=new WebSocket(n),r=$(s);try{return await Promise.race([r,T(e,t)]),s}catch(o){throw K(r),o}}i(F,"connect");async function K(n){try{(await n).close()}catch{}}i(K,"shutdown");function N(n,e){return W(i(()=>F(n,e.timeout,e.signal),"fn"),e.attempts,e.maxDelay,e.signal)}i(N,"connectWithRetry");function $(n){return new Promise((e,t)=>{n.readyState===WebSocket.OPEN?e(n):(n.onerror=()=>{n.onerror=null,n.onopen=null,t(new Error("connect failed"))},n.onopen=()=>{n.onerror=null,n.onopen=null,e(n)})})}i($,"whenOpen");class I{constructor(e,t,s){this.socket=null,this.opening=null,this.url=e,this.delegate=t,this.policy=s}async open(){if(this.opening||this.socket)return;this.opening=new AbortController;const e=Object.assign(Object.assign({},this.policy),{signal:this.opening.signal});try{this.socket=await N(this.url,e)}catch{this.delegate.socketDidFinish(this);return}finally{this.opening=null}this.socket.onclose=t=>{this.socket=null,this.delegate.socketDidClose(this,t.code,t.reason),(this.delegate.socketShouldRetry?!this.delegate.socketShouldRetry(this,t.code):C(t.code))?this.delegate.socketDidFinish(this):setTimeout(()=>this.open(),x(100,100+(this.delegate.reconnectWindow||50)))},this.socket.onmessage=t=>{this.delegate.socketDidReceiveMessage(this,t.data)},this.delegate.socketDidOpen(this)}close(e,t){this.opening?(this.opening.abort(),this.opening=null):this.socket&&(this.socket.onclose=null,this.socket.close(e,t),this.socket=null,this.delegate.socketDidClose(this,e,t),this.delegate.socketDidFinish(this))}send(e){this.socket&&this.socket.send(e)}isOpen(){return!!this.socket}}i(I,"StableSocket");function x(n,e){return Math.random()*(e-n)+n}i(x,"rand$1");function C(n){return n===z||n===J}i(C,"isFatal");const z=1008,J=1011;class j{constructor(e){this.buf=[],this.socket=e,this.delegate=e.delegate,e.delegate=this}open(){return this.socket.open()}close(e,t){this.socket.close(e,t)}send(e){this.socket.isOpen()?(this.flush(),this.socket.send(e)):this.buf.push(e)}isOpen(){return this.socket.isOpen()}flush(){for(const e of this.buf)this.socket.send(e);this.buf.length=0}socketDidOpen(e){this.flush(),this.delegate.socketDidOpen(e)}socketDidClose(e,t,s){this.delegate.socketDidClose(e,t,s)}socketDidFinish(e){this.delegate.socketDidFinish(e)}socketDidReceiveMessage(e,t){this.delegate.socketDidReceiveMessage(e,t)}socketShouldRetry(e,t){return this.delegate.socketShouldRetry?this.delegate.socketShouldRetry(e,t):!C(t)}}i(j,"BufferedSocket");class v{constructor(e){if(this.map=new Map,e)for(const[t,s]of e)this.set(t,s)}get(e){const t=this.map.get(e);return t||new Set}set(e,t){let s=this.map.get(e);return s||(s=new Set,this.map.set(e,s)),s.add(t),this}has(e){return this.map.has(e)}delete(e,t){const s=this.map.get(e);if(!s)return!1;if(!t)return this.map.delete(e);const r=s.delete(t);return s.size||this.map.delete(e),r}drain(e){const t=[];for(const s of this.keys())this.delete(s,e)&&!this.has(s)&&t.push(s);return t}keys(){return this.map.keys()}values(){return this.map.values()}entries(){return this.map.entries()}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}get size(){return this.map.size}}i(v,"MultiMap");class S{constructor(){this.subscriptions=new v,this.signatures=new Map}add(...e){const t=[];for(const{subscriber:s,topic:r}of e)this.subscriptions.has(r.name)||(t.push(r),this.signatures.set(r.name,r)),this.subscriptions.set(r.name,s);return t}delete(...e){const t=[];for(const{subscriber:s,topic:r}of e)this.subscriptions.delete(r.name,s)&&!this.subscriptions.has(r.name)&&(t.push(r),this.signatures.delete(r.name));return t}drain(...e){const t=[];for(const s of e)for(const r of this.subscriptions.drain(s)){const o=this.signatures.get(r);this.signatures.delete(r),t.push(o)}return t}topics(){return this.signatures.values()}topic(e){return this.signatures.get(e)||null}subscribers(e){return this.subscriptions.get(e).values()}}i(S,"SubscriptionSet");function*D(n,e){for(let t=0;t<n.length;t+=e)yield n.slice(t,t+e)}i(D,"eachSlice");function A(n){return new Promise((e,t)=>{const s=new Error("aborted");s.name="AbortError",n.aborted?t(s):n.addEventListener("abort",()=>t(s))})}i(A,"eventloop_tasks_whenAborted");async function q(n,e){let t;const s=new Promise(r=>{t=self.setTimeout(r,n)});if(!e)return s;try{await Promise.race([s,A(e)])}catch(r){throw self.clearTimeout(t),r}}i(q,"eventloop_tasks_wait");function H(n){return Math.floor(Math.random()*Math.floor(n))}i(H,"eventloop_tasks_rand");async function Y(n,e,t=1/0,s){const r=s?A(s):null;for(let o=0;o<e;o++)try{return await(r?Promise.race([n(),r]):n())}catch(c){if(c.name==="AbortError"||o===e-1)throw c;const a=Math.pow(2,o)*1e3,h=H(a*.1);await q(Math.min(t,a+h),s)}throw new Error("retry failed")}i(Y,"eventloop_tasks_retry");var R;(function(n){n.Deploy="Alive Redeploy",n.Reconnect="Alive Reconnect"})(R||(R={}));function V(){return`${Math.round(Math.random()*(Math.pow(2,31)-1))}_${Math.round(Date.now()/1e3)}`}i(V,"generatePresenceId");function G(n){const e=n.match(/\/u\/(\d+)\/ws/);return e?+e[1]:0}i(G,"getUserIdFromSocketUrl");class U{constructor(e,t,s,r){this.url=e,this.getUrl=t,this.inSharedWorker=s,this.notify=r,this.subscriptions=new S,this.state="online",this.retrying=null,this.connectionCount=0,this.presence=new k,this.presenceMetadata=new P,this.intentionallyDisconnected=!1,this.lastCameOnline=0,this.userId=G(e),this.presenceId=V(),this.presenceKey=p(this.userId,this.presenceId),this.socket=this.connect()}subscribe(e){const t=this.subscriptions.add(...e);this.sendSubscribe(t);for(const s of e){const r=s.topic.name;!m(r)||this.notifyCachedPresence(s.subscriber,r)}}unsubscribe(e){const t=this.subscriptions.delete(...e);this.sendUnsubscribe(t)}unsubscribeAll(...e){const t=this.subscriptions.drain(...e);this.sendUnsubscribe(t);const s=this.presenceMetadata.removeSubscribers(e);this.sendPresenceMetadataUpdate(s)}requestPresence(e,t){for(const s of t)this.notifyCachedPresence(e,s)}notifyCachedPresence(e,t){const s=this.presence.getChannelItems(t);s.length!==0&&this.notifyPresenceChannel(t,s)}updatePresenceMetadata(e){const t=new Set;for(const s of e)this.presenceMetadata.setMetadata(s),t.add(s.channelName);this.sendPresenceMetadataUpdate(t)}sendPresenceMetadataUpdate(e){if(!e.size)return;const t=[];for(const s of e){const r=this.subscriptions.topic(s);r&&t.push(r)}this.sendSubscribe(t)}online(){var e;this.lastCameOnline=Date.now(),this.state="online",(e=this.retrying)===null||e===void 0||e.abort(),this.socket.open()}offline(){var e;this.state="offline",(e=this.retrying)===null||e===void 0||e.abort(),this.socket.close()}shutdown(){this.inSharedWorker&&self.close()}get reconnectWindow(){const e=Date.now()-this.lastCameOnline<6e4;return this.connectionCount===0||this.intentionallyDisconnected||e?0:10*1e3}socketDidOpen(){this.intentionallyDisconnected=!1,this.connectionCount++,this.socket.url=this.getUrlWithPresenceId(),this.sendSubscribe(this.subscriptions.topics())}socketDidClose(e,t,s){if(this.redeployEarlyReconnectTimeout!==void 0&&clearTimeout(this.redeployEarlyReconnectTimeout),s==="Alive Reconnect")this.intentionallyDisconnected=!0;else if(s==="Alive Redeploy"){this.intentionallyDisconnected=!0;const o=(3+Math.random()*22)*60*1e3;this.redeployEarlyReconnectTimeout=setTimeout(()=>{this.intentionallyDisconnected=!0,this.socket.close(1e3,"Alive Redeploy Early Client Reconnect")},o)}}socketDidFinish(){this.state!=="offline"&&this.reconnect()}socketDidReceiveMessage(e,t){const s=JSON.parse(t);switch(s.e){case"ack":{this.handleAck(s);break}case"msg":{this.handleMessage(s);break}}}handleAck(e){for(const t of this.subscriptions.topics())t.offset=e.off}handleMessage(e){const t=e.ch,s=this.subscriptions.topic(t);if(!!s){if(s.offset=e.off,"e"in e.data){const r=this.presence.handleMessage(t,e.data);this.notifyPresenceChannel(t,r);return}e.data.wait||(e.data.wait=0),this.notify(this.subscriptions.subscribers(t),{channel:t,type:"message",data:e.data})}}notifyPresenceChannel(e,t){var s,r;const o=new Map;for(const c of t){const{userId:a,metadata:h,presenceKey:l}=c,u=o.get(a)||{userId:a,isOwnUser:a===this.userId,metadata:[]};if(l!==this.presenceKey){for(const f of h){if(d in f){u.isIdle!==!1&&(u.isIdle=Boolean(f[d]));continue}u.metadata.push(f)}o.set(a,u)}}for(const c of this.subscriptions.subscribers(e)){const a=this.userId,h=Array.from(o.values()).filter(f=>f.userId!==a),l=(r=(s=o.get(this.userId))===null||s===void 0?void 0:s.metadata)!==null&&r!==void 0?r:[],u=this.presenceMetadata.getChannelMetadata(e,{subscriber:c,markAllAsLocal:!this.inSharedWorker});this.notify([c],{channel:e,type:"presence",data:[{userId:a,isOwnUser:!0,metadata:[...l,...u]},...h]})}}async reconnect(){if(!this.retrying)try{this.retrying=new AbortController;const e=await Y(this.getUrl,1/0,6e4,this.retrying.signal);e?(this.url=e,this.socket=this.connect()):this.shutdown()}catch(e){if(e.name!=="AbortError")throw e}finally{this.retrying=null}}getUrlWithPresenceId(){const e=new URL(this.url,self.location.origin);return e.searchParams.set("shared",this.inSharedWorker.toString()),e.searchParams.set("p",`${this.presenceId}.${this.connectionCount}`),e.toString()}connect(){const e=new I(this.getUrlWithPresenceId(),this,{timeout:4e3,attempts:7});return e.open(),e}sendSubscribe(e){const t=Array.from(e);for(const s of D(t,25)){const r={};for(const o of s)m(o.name)?r[o.signed]=JSON.stringify(this.presenceMetadata.getChannelMetadata(o.name)):r[o.signed]=o.offset;this.socket.send(JSON.stringify({subscribe:r}))}}sendUnsubscribe(e){const t=Array.from(e,s=>s.signed);for(const s of D(t,25))this.socket.send(JSON.stringify({unsubscribe:s}));for(const s of e)m(s.name)&&this.presence.clearChannel(s.name)}}i(U,"alive_session_AliveSession");class O extends U{constructor(e,t,s,r){super(e,()=>this.getUrlFromRefreshUrl(),s,r);this.refreshUrl=t}getUrlFromRefreshUrl(){return Q(this.refreshUrl)}}i(O,"AliveSession");async function Q(n){const e=await X(n);return e&&e.url&&e.token?Z(e.url,e.token):null}i(Q,"fetchRefreshUrl");async function X(n){const e=await fetch(n,{headers:{Accept:"application/json"}});if(e.ok)return e.json();if(e.status===404)return null;throw new Error("fetch error")}i(X,"fetchJSON");async function Z(n,e){const t=await fetch(n,{method:"POST",mode:"same-origin",headers:{"Scoped-CSRF-Token":e}});if(t.ok)return t.text();throw new Error("fetch error")}i(Z,"post");function ee(n,e){for(const t of n)t.postMessage(e)}i(ee,"notify");function te(n,e,t){const s=i(r=>({subscriber:e,topic:r}),"toSub");if(t.subscribe&&n.subscribe(t.subscribe.map(s)),t.unsubscribe&&n.unsubscribe(t.unsubscribe.map(s)),t.requestPresence&&n.requestPresence(e,t.requestPresence),t.updatePresenceMetadata){for(const r of t.updatePresenceMetadata)r.subscriber=e;n.updatePresenceMetadata(t.updatePresenceMetadata)}t.online!=null&&(t.online?n.online():n.offline()),t.hangup&&n.unsubscribeAll(e)}i(te,"fromPort");function se(){let n=null;return function(e){const t=e.target,s=e.data;s.connect&&!n?n=new O(s.connect.url,s.connect.refreshUrl,!0,ee):n&&te(n,t,s)}}i(se,"withSocket");const ne=se();if(self.onconnect=n=>{const e=n.ports[0];e.onmessage=ne},typeof BroadcastChannel=="function"){const n=new BroadcastChannel("shared-worker-error");self.addEventListener("error",e=>{const{error:{name:t,message:s,stack:r}}=e;n.postMessage({error:{name:t,message:s,stack:r}})})}})();})();

//# sourceMappingURL=socket-worker-ec7956b25d0a.js.map